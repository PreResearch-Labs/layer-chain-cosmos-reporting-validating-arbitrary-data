# Forking Solutions

Each consumer chain and each individual user will have the option of accessing Tellor Layer data any way they want. At the very least, the Tellor team will deploy a light client bridge to various chains as needed. This bridge will rely on state proofs to verify the consensus state of the Tellor Layer chain and inclusion proofs to validate any relevant data to be read by oracle users. Oracle users will read their data through this bridge system. The bridge will use a proxy contract pattern to allow for updating its logic in the event of a Tellor Layer upgrade or some other fork so that users do not have to rely on their own governance for changing the contract address from which they read their data. Uncontentious logic upgrades can use the bridge itself to communicate a new proxy implemention address. In the event of some bug or attack on the Tellor Layer chain, however, there needs to be some way of alerting the bridge so that users do not read bad data, and so that the proxy contract can be updated to a new implementation. This subdirectory will hold various solutions to this problem. 

## Simple Schelling
### Description
The `SimpleSchelling` contract is one such solution which attempts to be more decentralized. This contract provides a simple Schelling game for pausing and updating a Tellor Layer Light Client Bridge contract in the event that the Tellor Layer chain is attacked or broken. Any user can pay a high fee to begin the Schelling game. Then either the bridge is immediately paused or an optional second signature is required from a configured guardian address. The initiator has a period of time to propose a new implementation address. Then anyone can pay to support or oppose the proposal. Once the voting period expires, the bridge is unpaused, and if the proposal is supported by a majority of the tokens, the bridge implementation address is updated. The winning side gets their tokens refunded and splits the losing side's tokens.

### Basic Function Flow
The basic flow using the SimpleSchelling contract's functions is as follows:
1. A user calls `initiateProposal` and pays at least `minInitAmount` tokens to start a Schelling game. Ten percent of this amount is burned, and the remainder is allocated as "for" votes for the proposed upgrade. If the contract does not require a guardian signature, the bridge contract is immediately paused. Otherwise, it's only paused after the guardian address also signs off on this Schelling game proposal.
2. If a guardian signature is required, the guardian address calls `guardianPauseBridge` to pause the bridge contract. This guardian could be a Tellor team multisig, a multisig controlled by an oracle data consumer, or some other interested party. It just acts as an additional backstop before pausing the bridge, and this requirement can be thrown away at any time by the guardian.
3. Once there is a new proxy implementation contract address ready, the game initiator calls `submitImplementation` before the proposal's submission period expires. 
4. Any interested party can participate in the Schelling game by calling `vote` with some token amount and a vote in favor or against the proposed implementation. In the end, the side with the majority of token votes wins. Each time a vote is submitted which causes the outcome to change, the vote expiration time is reset to `expirationPeriod` seconds in the future. This prevents a malicious vote at the very last second from switching and finalizing the outcome. 
5. During the voting period, voters (other than the game initiator) can call `updateVote` to change which side their existing vote goes to. When this causes the vote outcome to change, this also resets the vote expiration time similar to the `vote` function. However, 10% of their tokens are burned before being allocated to a new side. This makes it costly to grief the system by switching sides to keep the bridge paused for a longer period of time. 
6. After the voting period expires, anyone can call `executeProposal`. If a guardian signature is required but the guardian never signed the proposal, the proposal resolves to INVALID, the bridge was never paused, and the bridge continues working as if nothing ever happened. If the game initiator never submitted an implementation address or if the votes against outweigh the votes for the proposal, the proposal resolves to AGAINST and the bridge is unpaused, continuing with the existing implementation address. Otherwise, if the votes for outweight the votes against, the proposal resolves to FOR, the bridge is unpaused and the proxy implementation address is updated to the new address.
7. After a proposal is executed, any relevant parties can call `claim` to claim their tokens. If the proposal resolved to INVALID, all parties can claim refunds of their submitted tokens, minus any previously burned amounts. If the proposal resolved to FOR, anyone with votes on the "for" side gets their tokens refunded (minus any burned tokens) and splits a proportional amount of the tokens from the opposing side. The same, opposite logic applies if the proposal resolved to AGAINST.

### Design Choices
The objective of this Schelling game contract is to act as a security mechanism. In the event of an attack or bug on the Tellor Layer chain, we want a way to stop oracle data consumers from using bad data, and we want a way to recover from such an event. The `minInitAmount` should be set high enough to make it too expensive to grief the system by pausing the oracle bridge, but low enough for someone to be able to pay in a real emergency situation. The guardian logic adds another backstop so that some trusted party's approval is required before pausing the oracle bridge. 

In a real emergency situation, we would want to quickly act and pause the bridge immediately so that users' protocol do not consume bad oracle data. However, a new bridge implementation address probably would not be available immediately. Therefore, this Schelling game allows for fast, expensive bridge pausing, and then an extra period of time during which a new proxy implementation contract can be deployed and then submitted. 

## Other Solutions
Some alternative solutions could be using oracle consumer protocols' governance or multisigs or Eigenlayer.